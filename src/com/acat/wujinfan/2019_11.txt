2019.11.01-03(周五,周六,周日)
    这周休假一天，放了3天假。
    周六去跟大学室友去望京转了会，吃了个饭小聚一下，看了场电影《少年的你》。
    周日下午帮同学搬家去了。然后瞎转悠转到了软件园那边，那块大公司挺多的，也挺震撼的，是真的震撼啊......

2019.11.04(周一)
    1.早上来公司写周报,参加部门的晨会。
    2.业务中遇到一个小问题，对于pad端显示的固定字段，统一处理是在后端写死，再传给pad端，这样后端就保存了最原始的镜像，如果是在
      pad端生成的话，就不会过后端，这样后端就不会保存这个数据。但是在看个代码之后，和这个业务相同的业务之前是这样的，直播的固定字
      段是在后端生成的，但是备播的字段却是在前段那边生成的，有点懵逼，不知道这个是为啥。
    3.给显示总积分寻找最优的方法。
    4.测试微服务之间接口调用:
      remote(父项目，也是被需要调用接口的项目),防止端口冲突，port为8899,https://github.com/rocky1996/remote
      local(子项目，也是需要调用别人接口的项目,防止端口冲突，port为8080,https://github.com/rocky1996/local

      local项目中通过feign调用远程接口，此时并没有设置熔断时间，默认为1000毫秒。
      local项目中添加eureka注册中心等环节。
    5.之前很少使用的一个git的命令，git本地提交到缓存区,如果想退回，使用命令git reset HEAD^即可

2019.11.05(周三)
    继续昨日的搭建:
        1.在昨日的基础上在服务里面搭建日志服务器，收集日志，按"天"来记录。

    Spring总结:
        1.Spring作用在类上的注解又@Component,@Responsity,@Service,@Controller;而@Autowired和@Resource用来修饰字段,构造函
          数或者设置方法,并做注入的。
        2.当注解作用在类上时，表明这些类是交给spring容器进行管理的，而当使用@Autowired和@Resource时，表明我需要某个属性、方法或
          字段，但是并不需要我自己去new一个，只需要使用注解， spring容器会自动的将我需要的属性、方法或对象创造出来。这就是通常所说
          的依赖注入和控制反转。
        3.@Component对那些比较中立的类进行凝视,随便一个类就可以,有了这个注解就表示,把这个类交给Spring容器去管理。

    处理线上问题:
        之前别人写的代码,属于互动情况考虑不全的问题,但是代码版本迭代太多,代码稍微有点乱,修复起来有点困难,好在在导师的帮助
        下定位出了问题,下一步进行修复。
    晚上回去跑圈去。

2019.11.06(周三)
    1.中午休息的时候，无意中看到了部门大总监田密老师内部的演讲视频,讲的非常棒,感觉很有所触动。
    2.工作进程:今日起进入到1209版本的开发阶段,领取新版本的开发任务(3个)进行开发。
    3.对新老注解的认识:
        <1>
            @RestController和@Controller的区别:
            @RestController = @ResponseBody + @Controller

            @Controller类中的方法可以直接通过返回String跳转到jsp,html里面，只有通过@ResponseBody注解才可以返回String,Object,json等对象.
            @RestController类中的方法只能返回String,Object,json等对象.
        <2>
            @Autowried和@Resource的区别:
            相同:都是用来装配bean,均可用于字段或者setter方法
            不同:@Autowried是Spring提供
                默认情况下要求对象必须存在, 它要求依赖对象必须存在. 若允许null值, 可以设置它的required为false.
                默认按照类型进行装配注入. 如果想按照名称进行装配的话, 需要与Qualifer注解搭配使用.

                @Resource是J2EEt提供
                默认按照名称来装配注入, 只有找不到与名称匹配的bean才会按照类型来注入.
                name: Spring将name的属性值解析为bean的名称, 使用byName的自动注入策略
                type: Spring将type的属性值解析为bean的类型, 使用byType的自动注入策略
                如果既不指定name属性又不指定type属性, Spring这时通过反射机制使用byName自动注入策略
                name > type
        <3>
            @Configuration注解标注在类上面,相当于把类作为spring的xml配置文件中的<bean>，作用为:配置spring容器.
            @Configuration等价于<Beans></Beans>
            @Bean等价于<Bean></Bean>
            @ComponentScan等价于<context:component-scan base-package="com.acat.xxx"/>

        <4>
           @Qualifier合格的意思,使用场景是:
                public interface EatLunch{}
            该接口有两个实现类
                @Service("eatLunchImpl1")
                public class EatLunchImpl1 implements EatLunch(){}

                @Service("eatLunchImpl2")
                public class EatLunchImpl2 implements EatLunch(){}

            在controller里面进行@Autowried注入的时候，系统不知道调用的是哪一个实现类,于是就使用到了这个注解
                @Autowried
                @Qualifier("eatLunchImpl1")
                private EatLunch eatLunch;

    4.回家修复线上bug,未解决，明日再看吧

2019.11.07(周四)
    1.接着修复昨天的bug。在修复的时候把对之前代码的删除效率问题进行了重新的修复,遇到批量修改,批量删除的任务,尽量避免在代码层次上进行循环操作,而是使用批量的SQL语句
      int delPhoto(List<String> list);
      <delete id="del" parameterType="java.util.List">
          DELETE FROM rti_material_img WHERE id IN
          <foreach collection="list" index="index" item="item" open="(" separator="," close=")">
              #{item}
          </foreach>
      </delete>
    2.在开发中注意到了一个问题，也是需要注意的地方，在接口开发中接口的公参尽量不要去使用,需要什么参数让前端给传什么参数,
      哪怕传的参数和公参里面的一样

    3.昨天遇到了一个新版本需求的任务,需要找产品碰一下,商量之后砍掉了。
    4.下午开发完毕图片上墙表扬部分。
    今天买了一张《平凡的世界》的话剧票，下周去看话剧去。哈哈哈😄
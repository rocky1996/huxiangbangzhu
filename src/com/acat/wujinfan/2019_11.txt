2019.11.01-03(周五,周六,周日)
    这周休假一天，放了3天假。
    周六去跟大学室友去望京转了会,吃了个饭小聚一下,看了场电影《少年的你》。
    周日下午帮同学搬家去了。然后瞎转悠转到了软件园那边,那块大公司挺多的,也挺震撼的,是真的震撼啊......

2019.11.04(周一)
    1.早上来公司写周报,参加部门的晨会。
    2.业务中遇到一个小问题,对于pad端显示的固定字段,统一处理是在后端写死,再传给pad端,这样后端就保存了最原始的镜像,如果是在
      pad端生成的话,就不会过后端,这样后端就不会保存这个数据。但是在看个代码之后,和这个业务相同的业务之前是这样的,直播的固定字
      段是在后端生成的,但是备播的字段却是在前段那边生成的,有点懵逼,不知道这个是为啥。
    3.给显示总积分寻找最优的方法。
    4.测试微服务之间接口调用:
      remote(父项目，也是被需要调用接口的项目),防止端口冲突，port为8899,https://github.com/rocky1996/remote
      local(子项目，也是需要调用别人接口的项目,防止端口冲突，port为8080,https://github.com/rocky1996/local

      local项目中通过feign调用远程接口，此时并没有设置熔断时间，默认为1000毫秒。
      local项目中添加eureka注册中心等环节。
    5.之前很少使用的一个git的命令，git本地提交到缓存区,如果想退回，使用命令git reset HEAD^即可

2019.11.05(周三)
    继续昨日的搭建:
        1.在昨日的基础上在服务里面搭建日志服务器,收集日志,按"天"来记录。

    Spring总结:
        1.Spring作用在类上的注解又@Component,@Responsity,@Service,@Controller;而@Autowired和@Resource用来修饰字段,构造函
          数或者设置方法,并做注入的。
        2.当注解作用在类上时，表明这些类是交给spring容器进行管理的，而当使用@Autowired和@Resource时,表明我需要某个属性,方法或
          字段，但是并不需要我自己去new一个,只需要使用注解,spring容器会自动的将我需要的属性、方法或对象创造出来。这就是通常所说
          的依赖注入和控制反转。
        3.@Component对那些比较中立的类进行凝视,随便一个类就可以,有了这个注解就表示,把这个类交给Spring容器去管理。

    处理线上问题:
        之前别人写的代码,属于互动情况考虑不全的问题,但是代码版本迭代太多,代码稍微有点乱,修复起来有点困难,好在在导师的帮助
        下定位出了问题,下一步进行修复。
    晚上回去跑圈去。

2019.11.06(周三)
    1.中午休息的时候，无意中看到了部门大总监田密老师内部的演讲视频,讲的非常棒,感觉很有所触动。
    2.工作进程:今日起进入到1209版本的开发阶段,领取新版本的开发任务(3个)进行开发。
    3.对新老注解的认识:
        <1>
            @RestController和@Controller的区别:
            @RestController = @ResponseBody + @Controller

            @Controller类中的方法可以直接通过返回String跳转到jsp,html里面，只有通过@ResponseBody注解才可以返回String,Object,json等对象.
            @RestController类中的方法只能返回String,Object,json等对象.
        <2>
            @Autowried和@Resource的区别:
            相同:都是用来装配bean,均可用于字段或者setter方法
            不同:@Autowried是Spring提供
                默认情况下要求对象必须存在, 它要求依赖对象必须存在. 若允许null值, 可以设置它的required为false.
                默认按照类型进行装配注入. 如果想按照名称进行装配的话,需要与Qualifer注解搭配使用.

                @Resource是J2EEt提供
                默认按照名称来装配注入, 只有找不到与名称匹配的bean才会按照类型来注入.
                name: Spring将name的属性值解析为bean的名称, 使用byName的自动注入策略
                type: Spring将type的属性值解析为bean的类型, 使用byType的自动注入策略
                如果既不指定name属性又不指定type属性, Spring这时通过反射机制使用byName自动注入策略
                name > type
        <3>
            @Configuration注解标注在类上面,相当于把类作为spring的xml配置文件中的<bean>，作用为:配置spring容器.
            @Configuration等价于<Beans></Beans>
            @Bean等价于<Bean></Bean>
            @ComponentScan等价于<context:component-scan base-package="com.acat.xxx"/>

        <4>
           @Qualifier合格的意思,使用场景是:
            该接口有两个实现类
                @Service("eatLunchImpl1")
                public class EatLunchImpl1 implements EatLunch(){}

                @Service("eatLunchImpl2")
                public class EatLunchImpl2 implements EatLunch(){}

            在controller里面进行@Autowried注入的时候，系统不知道调用的是哪一个实现类,于是就使用到了这个注解
                @Autowried
                @Qualifier("eatLunchImpl1")
                private EatLunch eatLunch;

    4.回家修复线上bug,未解决，明日再看吧

2019.11.07(周四)
    1.接着修复昨天的bug。在修复的时候把对之前代码的删除效率问题进行了重新的修复,遇到批量修改,批量删除的任务,尽量避免在代码层次上进行循环操作,而是使用批量的SQL语句
      int delPhoto(List<String> list);
      <delete id="del" parameterType="java.util.List">
          DELETE FROM rti_material_img WHERE id IN
          <foreach collection="list" index="index" item="item" open="(" separator="," close=")">
              #{item}
          </foreach>
      </delete>
    2.在开发中注意到了一个问题，也是需要注意的地方，在接口开发中接口的公参尽量不要去使用,需要什么参数让前端给传什么参数,
      哪怕传的参数和公参里面的一样

    3.昨天遇到了一个新版本需求的任务,需要找产品碰一下,商量之后砍掉了。
    4.下午开发完毕图片上墙表扬部分。
    今天买了一张《平凡的世界》的话剧票，下周去看话剧去。哈哈哈😄

2019.11.08-09(周五,周六)
    1.早上一直在看一站到底的逻辑代码,两个版本的代码,闹了点笑话。
    2.下午和pad端老师联调了已经写好的一个接口
    3.导入一站到底的繁体题库到数据库中,在导入的时候遇到了一个麻烦,需要导入的数据有2700多条,而导进去了发现少了20多条,一直在担心是性能并发问题,导致数据丢失,后来找leader
      研究后觉得不是并发的问题,即有可能是代码层次的问题,后来重新看了代码发现,在插入的时候有做了一个判断,判断新插入的数据在数据库里面有没有存在，存在的话就拒绝插入了,
      而简体和繁体公用的是一个数据库,而数据库之前只有简体的数据,而这期插入的时候有的繁体和数据库已经存在的简体是一样的,所以就拒绝插入了,注释到判断语句,就ok了。
    4.周五晚上参加新版本部门的技术评审会议
    5.今天发工资啦😄😄😄
    6.周六和大学室友去爬香山了,山上很美，很美

2019.11.10-11(周天,周一)
    1.周天在家收拾屋子，晚上学着煮稀饭。
    2.周一早上公司开晨会，和产品沟通新版本的具体细节。
    3.开发完毕一站到底繁体版(待优化),明天和导师商量优化的细节。
    4.晚上回去跑圈去。

2019.11.12(周二)
    1.修复表扬上墙的数据库表的某一参数指定值,修改调用SQL语句,适配pad端进行调用。
    2.优化一站到底的繁体部分逻辑代码。防止线上数据库出错,将本地数据库还原到之前的版本,将旧表中的数据迁移到新表中,待上线前将旧表删除即可。
    3.接触到了两条导入数据库表的命令,在导表的时候使用到了,按道理说之前就应该要用到呀:
        create table newtable select * from oldtable;(新老表数据结构一样,将oldtable的数据导入到newtable中,newtable没有创建)
        insert into newtable select * from oldtable;(新老表数据结构一样,将oldtable的数据导入到newtable中,newtable已经创建)
    4.接到新需求,下课互动优化,晚上看需求和测试端同事联系,明天进入开发阶段。
    5.晚上抢红包,抢了20多,哈哈😄😄😄

2019.11.13(周三)
    1.重新复盘下课互动优化的需求后,两个等解决问题得以解决,优化下课需求开发完毕。
    2.无意中看到了36k里面的一篇文章,https://36kr.com/p/5265736,是关于投资企业的一些东西,顺便百度了一下里面出现的一些企业，总感觉收获颇多。
    3.明天进入开发本版本的最后一个需求。

2019.11.14(周四)
    1.早上和前端和pad端进行联调课后优化部分。
    2.下午开始接触系统功能优化那块的业务逻辑需求,进入开发阶段,只是局部优化,开发完毕。
    3.给remote和local项目初始化mongo缓存,修改项目访问的二级路由设置。
    4.晚上看一站到底直备播逻辑,后期要进行路演。

2019.11.15(周五)
    1.gitlab提交新增下课逻辑优化代码。
    2.在导师的提醒下,重新优化开启下课接口的逻辑,之前的接口编写部分情景考虑不周。
    3.接着昨天晚上的继续整理一站到底的流程逻辑。

2019.11.16-17(周六,周天)
    1.周六苦逼公司加班😞😞😞
    2.周天在家睡了一天,下午找学长出去吃饭去了

2019.11.18(周一)
    1.重新0916版本的辅导扣积分方法,之前扣积分那块远程调用feign里面的加积分的方法,但是传的是个负数,这次为扣积分单独写一个方法,传入正数即可。
    2.为随机点名新增一个pad端关闭的接口,今天在写的时候忽然有一种豁然开朗的感觉,好像对其中的某一块的业务忽然就明白了的那种感觉。是由pad端调用,通知学生大屏。
    3.再次优化开启下课的接口,增加考虑下课的情况。
    4.再再次更新优化开启下课接口,还是考虑情况不周,不应该纠结于连续的下课,应该关心于整个课堂其他的互动的状态,或者说只要不是NORMAL就可以了,然后在去判断下课
      的次数,先是状态判断再是下课次数判断,明天再去看主讲或者辅导的状态对下课的影响。

2019.11.19(周二)
    1.参加新版本的测试用例评审。
    2.优化"讲题"模版,翻写接口,兼容新老版本。
    3.优化"随机点名"接口,重新命名"互动中结束"的指令。
    4.感觉自己平时在开发的时候老是被产品和别的端那边牵着鼻子走,好像不知道去反抗,今天被导师说了一下,以后记住了。
    5.push rejected问题。
    6.继续local项目的编写。

2019.11.20(周三)
    1.终于搞懂了线上日志的分布了,公司采用了日志的分布式存储,每天都会打日志到服务器,并且是随机打到不同的服务器上面,不过说实话,这个线上的命名有点不太规范,当时一时半会还弄不太懂。
    2.和pad端和pc端讨论课清那块的按钮置灰问题,看似不太复杂的问题,牵扯到了很多的问题,最后商量到了一个折中的问题,随机修改代码即可。
    3.初次接触代码中自定义的注释,以后可以自己定义新的注解以符合自己的项目的注解,在aop里面进行切片的配置,例如此次的@APIAuth注解。

2019.11.21(周四)
    1.String str1 = null;
        System.out.println(StringUtils.isBlank(str1));//true
      String str2 = "";
        System.out.println(StringUtils.isBlank(str2));//true
      String str3 = "   ";
        System.out.println(StringUtils.isBlank(str3));//true
        System.out.println(StringUtils.isEmpty(str3));//false
      今天在这里踩了次坑,以后要记住。
    2.今天的1209版本进入到联调阶段,开始和别的端进行接口的调试。遇到的第一个问题就给我打蒙了,我在本地调试好的接口放到开发环境里面就访问不了了,一时半会还不知道是啥原因,忽然间想
      起来了,昨天部门在所有的接口上面添加了鉴权,所以走网关的接口需要添加设置的公参来响应鉴权,添加之后,ok。
    3.今天测试那边专门开了一个香港那边的账号,我把一站到底繁体版联测了一下,暂时没有问题。
    4.下课互动那块一直在进行联调,今天为测试那边的老师专门写了一个清除缓存的临时的接口。
    5.晚饭后参加新版本的数据埋点的评审会议。

2019.11.22-23(周五,周六)
    周五:
        1.从早上到下午一直都在排查下课互动优化那块的课堂状态的问题,一直不太清楚为啥点击"课清"卡片的时候课堂状态会变成"AFTER_CLASS",最后竟然会定位到佩奇工具这块,
          有点出乎我的意料了,只能等待佩奇那边出一个新包安装一下,重新配置卡片时间再测,今天估计是测不了了。
        2.忽然发现我对经济投资之类的好像还挺感兴趣的,但是不知道接下来该做什么,我总觉得最起码得有一个类似于"店"的一个实物存在才有资格谈这个,谈以后。
    周六:
        1.在家睡了一天,一会出去吃个晚饭。

2019.11.24-25(周天,周一)
    周天:
        1.在家收拾屋子,跟猪窝一样,洗衣服,剪发,周六周天过的好快啊。
    周一:
        1.早上上班写周报,汇报上周工作。
        2.更新重组返回的表扬列表中的讲题模版的位置,本想着在sql层次对顺序做一个排序返回,但是发现对象字段中没有一个合适的字段来进行排序,只能在service层单写方法进行顺序的重组。
        3.Failed to convert value of type 'java.lang.String' to required type 'long'; nested exception is java.lang.NumberFormatException: For input string: "10*60"问题,
          解决的办法是以后尽量在配置文件里面,尽量少出现类似于10*60这样形式的存在,更换成600就可以了。
        4.今天联调结束。
        5.接到了一个线上的问题,目前正在排查。代码貌似看懂了,但是我不知道从那块开始查起。

2019.11.26(周二)
    1.今天提测,有bug进来了,正在紧急修复。今天遇到了一个很怪异的问题,明天再修复吧。

2019.11.27(周三)
    1.昨晚9点版本开始提测,今天进来7个bug(其实是3个),今天解决bug有以下的总结:
        (1).看似简单的功能,因为兼容新老版本时候考虑情况不足,导致在某种特定情况下不能满足客户需求,在自测的时候没有测到,测试毕竟是测试,考虑的就是全啊。
        (2).现在的功能都是微服务之间的相互调用,存在一种情况就是你写的功能代码没有问题,但是微服务调用别的代码那块出问题,间接导致此处功能报错,这也是一种情况,此时候应该重点把心思放到熔断处理的问题上面。
        (3).搞不懂一个bug,有三个测试老师给我提过来了,瞬间一个bug就变成3个bug了。
    2.下午参加明年3月份的需求评审,晚上我导师中哥让我先挑选下期的需求,啦啦啦
    3.还有一个就是,本来是一个小bug,被我改的问题大了,尴尬很......,不晓得咋改了。
    意外收获:听到了几个新词,同股同权,同股不同权。

2019.11.28-29(周四,周五)
    周四:
        1.将除过异常恢复外的其他bug已经bug fixed,其余时间全部在异常恢复上面。
        2.情绪有点低落。
    周五:
        1.今天产品又重新加了一个需求,后来导师和产品和pad端又重新去讨论快一个小时,最终产品妥协,将需求砍掉了。
        2.今天重新整理思路,把异常恢复时间和状态重新在纸上画了一遍,对应为啥在报名阶段有学生报名时,异常恢复时是没问题的,而在没人报名时异常恢复时现实的状态不对。在刚才把那个问题解决了,但是感觉还是有偶然性,或
          者说中间夹杂着猜的成分,幸好问题解决了,还是有点兴奋,快三天了,终于解决了。私底下还得重新在滤清一下,这块的状态转换和时间倒计时是真的复杂。
        3.今天上映新电影《一生有你》,今天下班早,我看电影呀。
        4.查看明年3月份的版本需求,领取新的需求。
        5.明天争取把remote和local的后端数据架构搭建起来,采用kafak + es + flume。

2019.11.30(周六)
    今天起的很晚,有点感冒了,肯能是昨天在外面看雪受凉了,中午吃完饭后又迷迷糊糊的睡了,晚上实验室的小伙伴叫出去吃饭,聊了好多,什么找对象啊,工作啊之类的,本来说好的今天弄remote和local那块的代码,也没弄成,明天就是12月份了,加油努力干吧。


***********************************************************************************************
List  set  map都是接口前两个继承与collection（下满还有一个queue 接口 有priorityqueue)  Map为独立的接口
***********************************************************************************************
Set有 hashset  linkedhashset tree set
List 有arraylist  vector  linkedlist
Map :hashtable   linkedhashmap     hashmap  treemap
linkedList 既可以实现Queue接口也可以实现list接口。Queue接口窄化了对linkedlist的方法的访问权限，（参数类型是queeu就完全只能访问queue接口所定义的方法，而不能直接访问linkelist的非queue方法）
Sortedset是个接口，它里面（只有treeset这一个实现可用）的元素有一定顺序
List有序可重复
Arraylist
优点：底层数据结构是数组  查询快增删慢
缺点：线程不安全，效率好
Vector
优点：底层数据结构是数组  查询快 增删慢
缺点：线程安全 效率低
Linkedlist
优点  底层数据是链表  查询慢增删快
缺点：线程不安全  效率高
Set无序 唯一
Hashset：无序唯一
底层数据结构哈希表  唯一性由函数 hashcode（）和equals（）
Linkedhashset  FIFO插入有序唯一
底层数据结构是哈希表和链表 有序是链表  唯一是哈希表
 Treeset  唯一有序
底层数据结构红黑树  元素排序是自然排序和比较器排序   唯一性根据比较的返回值是否是0   三者都不安全  HashSet插入数据最快，其次LinkHashSet，最慢的是TreeSet因为内部实现排序
怎样选择collection集合  通过判断你的数据是否唯一 是否安全  是否排序来决定
唯一肯定用set是否排序hashset无序 linkedhashset和treeset有序
不唯一list安全性vector是安全的 linkedlist和arraylist是不安全的
HashSet和LinkHashSet允许存在null数据，但是TreeSet中插入null数据时会报NullPointerException
如果你知道是Collection集合，但是不知道使用谁，就用ArrayList。
如果你知道用集合，就用ArrayList。
如果你知道是List，但是不知道是哪个List，就用ArrayList。
如果你知道是Set，但是不知道是哪个Set，就用HashSet。

map接口有三个比较重要的实现类 分别是hashmap  treemap  hashtable
Treemap是有序的
hashmap（方法不同步，线程不安全，效率高）和hashtable（方法同步，线程安全，效率低）是无序的
如果对同步性或与遗留代码的兼容性没有任何要求 建议使用hashmap
Hashtable中的所有public方法声明都有synchronized关键字（同步关键字 ，主要用来处理java中 的同步机制，同步机制就任意时间只能有一个兄弟访问，不会出现两个人同时修改一个变量的情况）
Hashtable不允许null值，hashmap允许null（key和value都可null）
Hashtable的父类是dictionary  hashmap是abstractmap
***********************************************
框架
***********************************************
orm对象映射关系
pojo是简单的java类它通常是指没有entity beans的普通java对象（实体类）
ibatis 的sql语句需要自己动手写
Hibernate的sql能够在程序运行时自动生成，且hibernate可以自动建表。好处就是带着程序在什么机器上都不需要数据库，因为会自动完成。而ibatas就必须有数据库表

Hibernate的特点：数据库无关性好  O/R(对象/关系)映射能力强， orm实现了pojo和数据库表之间的映射。程序员只需要定义pojo和数据库表之间的映射关系。
Ibatis的特点： 相对于hiberbate o/r而言 ibatis是一种sql mapping  着力点则在于POJO 与SQL之间的映射关系。
***********************************************
算法
***********************************************
排序算法是为了将杂乱的数据按一定规则将其排列好。是数据得以快速检索，这就是排序的目的
可以从时间，空间，稳定性来衡量算法的好坏
如果排序不需要借助外部储存器，所有操作都在内存中完成，则称之为内部算法。
如果参与排序的数据元素非常多，数据量非常大咋计算机必须借助外部储存器如磁盘  则这种排序可成为外部排序

直接插入排序：
算法思想：将无序的数据通过逐次比较变为有序的数据，每次比较时和目前最大或最小的数进行比较，若条件成立在和排好的其他数据用循环进行比较，直到最后排序完毕。
最好时间复杂度o(n) 此时内层循环始终不成立
最坏时间复杂度是O（n^2）此时内层循环始终成立 n*(n-1)/2
平均时间复杂度是O（n^2）
空间复杂度是O（1）辅助存储空间不随带排序列规模的变化而变化
稳定性：稳定  当遇到相等的数字时不会改变原有的排序
eg:举个例子吧，
{0,11,9，’11‘};
例子而稳定的应该是这样   为标记的’11‘  不是字符"11"
{0,9，11, ’11‘ }
折半插入排序：
算法思想：是数据已经有序 然后插入数据排序  low high m=【（low+high）/2】下取整每次的low high m都会变化  循环条件就是low<high
平均时间复杂度：O（n^2）折半插入排序适合关键字数较多的场景，
时间最好情况：O（nlog2n）
时间最差情况：O（n^2）
空间复杂度是O（1）
稳定性是稳定  例子和上述一致
10.16总结:感觉自己进度很慢很无知，加油吧。后面尽可能快一点。时间上不能完全跟计划，后面尽量排除无关事件。


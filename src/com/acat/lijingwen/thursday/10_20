*****************************
网络编程TCP/UDP
*****************************


基于TCP协议的网络编程
TCP：传输控制协议  被称为一种端对端协议，是一种面向连接的可靠的，给予字节流的传输层的通信协议，可以连续传输大量的数据。
步骤：
服务器程序的工作过程包含以下五个基本步骤：
1.使用ServerSocket(int port)创建一个服务器端套接字，并绑定到指定端口上。用于监听客户端的请求。
2.调用accept()方法：监听连接请求 如果客户端请求链接，则接受链接 创建于该客户端的通信套接字对象，否则该方法一直处于等待状态。
3.调用该socket对象的getOutputStream() 和getInputStream():获取输出流和输入流  开始网络数据的发送和接收。
4.关闭Socket对象， 某客户端访问结束，关闭与之通信的套接字。
5.关闭ServerSocket:如果不再接收任何客户端的连接的话，调用close()进行关闭
客户端socket的工作过程包含以下四个基本的步骤：
6.创建socket：根据指定服务断的IP地址或端口号构造socket 类对象，创建的同时会自动向服务器方发起连接。若服务器端响应，则建立哭护短到服务器的通信线路。若链接失败，会出现异常。
7.打开连接到socket的输入/输出流：使用getInputStream()方法获得输入流，使用getOutput
Stream()方法获得输出流 ，进行数据传输
8.进行读写操作：通过输入流读取服务器发送的信息，通过输出流将信息发送给服务器
9.关闭socket：断开客户端到服务器的链接
UDP：是一个无连接的传输层协议，提供面向事物的简单不可靠的信息传输服务
特点：将数据，源，目的封装成数据包，不需要建立连接
      每个数据报的大小限制在64K

      因无需连接，故不可靠，速度快

流程：
1.建立发送端的DatagramSocket，需要制定本端的端口号
2.建立数据包DatagramPacket
   数据
   接收端的IP地址
   接收端的端口号
3.调用Socket的发送方法
4.关闭socket


UDP协议的使用场景：即时通讯   在线视频  网络语音电话
类DatagramSocket和DatagramPacket实现了基于UDP协议网络程序

DatagramPacket：数据包对象    作用：用于封装要发送或接收的数据   比喻：集装箱
构造方法：1.DatagramPacket（byte[] buf,int length,inetAddress,int port）
DatagramSocket：发送或接受对象   作用：用来发送数据包或接收数据包   比喻：码头
构造方法：Datagramsocket()
*******************************************************************************
八、数据库 MySql
*******************************************************************************
1.MySQL 的存储引擎的不同
Mysql的存储引擎包括MyISAM   InnoDB  BDB   MEMORY   MERGE  EXAMPLE
NDB CKUSTER  ARCHIVE等   其中InnoDB和BDB支持事务安全，TokuDB高写性能高压缩存储引擎   Infobright列示存储引擎
使用  show engines \G;   这个可以查看当前数据库支持的存储引擎
MyISAM：是5.5之前默认的存储引擎
优势：访问速度快
使用场景：对事务的完整性没有要求，或以select insert 为主的应用基本都可以选用MYISAM。在web和数据仓库中应用广泛。
特点：
A.不支持事务外键
B.每个MYISAM在磁盘上存储为3个文件，文件名和表名相同 扩展名分别是
.frm  存储表定义
.MYD MYData  存储数据
.MYI  MYIndex  存储索引
数据文件和索引文件可以放在不同的目录，平均分布IO，加快访问速度  在创建表的时候通过data directory  和index  directory 来指定存储路径
C.支持三种不同的存储格式
静态表（fixed）
默认的存储格式   静态表中de字段都是非变长字段 每个记录都市固定长度 当表不包含变量长度列时  使用这个格式
优点：存储迅速出现故障容易恢复
缺点：占用空间比动态表大，静态表在进行数据存储时会按照时间定义的列宽度补足空格，但在访问的时候会去掉这些空格。（如果数据本身带有空格 再返回的时候会去掉数据本身自带的末尾空格，前面的会保留）
动态表:
包含变长字段 如Varchar   text 等或者建表时row_format=dynamic指定，则该表使用动态格式存储。
优点：占用空间小
全店：频繁的更新和删除操作会产生碎片，需要定期用optimize table 语句或mysaimchk -r 命令来改善性能 并且在出现故障后较难恢复。
压缩表：
由myisampack工具创建 占据非常小的磁盘空间 因为每个记录都市被单独压缩的

InnoDB  Mysql5.5之后的默认存储引擎
应用场景：如果应用对事务的完整性有较高的要求，在并发条件下要求数据的一致性，数据操作中包含读，插入，删除，更新，那InnoDB是最好的选择。在计费系统，财务系统等对数据的准确性要求较高的系统中被广泛应用。
优点：提供了具有提交，回滚崩溃iuhuifunengli事务安全，支持外键。
缺点：相比较MyISAM写的处理效率差一点，并且会占用更多的磁盘空间来存储数据和索引。
特点：
自动增长列
InnoDB表的自动增长列必须是索引，如果是组合索引，也必须是组合索引的第一列
MyIsam表的自动增长列可以是组合索引的其他列
设置自动增长列：creat表时，在字段后加auto_increment
外键约束
Mysql的存储引擎中只有Innodb支持外键约束
注意：当某个表被其他表创建了外键参照，那么该表对应的索引和主键禁止被删除
当导入多个表的数据室如果要忽略表之前导入的顺序，或者当执行load data 和alter table
操作，为了提高处理速度的时候可以暂时关闭外键约束命令为：set foreign_key_checks=0
存储方式：
InnoDB存储数据和索引有共享表空间存储和独占表空间存储两种方式
通过参数：innodb_file_per_table 控制0为共享空间 1为独占空间
共享表空间：每一个数据库的表的数据索引都保存在一个文件中  默认在data目录下大小为10M 通过参数innodb_data_file_path来制定存储路径
优点：可以将表空间分为多个额文件放在不同磁盘上  分布IO提高性能
       表数据和表结构放在一起方便管理
缺点：由于所有的数据和索引都是在文件中混合存储  这样的话对一个飚了大量的删除操作后表空间就会产生大量空隙。
独占表空间存储：
每一张表都有自己独立的表空间，表的结构依然在.frm文件中，还有一个后缀为.ibd的文件，保存了这张表的数据和索引。
优点：
每张表都有自己独立的表空间，可实现单表在不同数据库中移动
空间可回收。drop table会自动回收；删除数据后，通过alter table emp engine=innodb也可回收不用的表空间
效率和性能会好一些
缺点：由于每个表的数据都是以一个单独的文件来存放，所以会受到文件系统的大小限制
MEMORY：使用保存在内存中的数据来创建表 每个memory表对应一个磁盘文件  格式是.frm
特点：由于他的数据是存放在内存中的，并且默认使用hash索引，所以它的访问速度特别快，同时也造成了他的缺点，数据库服务一旦关闭数据就会丢失，另外对标的大小有限制。
使用场景：内容变化不频繁的代码表，作为统计操作的中间结果表，便于利用它速率快的优势搞笑对中间结果进行分析。
MERGE ：
Merge表是一组MYISAM表的组合  ，這些MYISAM表的结构本身并没有数据，对他的操作实际上是对内部MYISAM表的操作。
应用场景：用于将一系列MyISAM表以逻辑方式组合在一起，并作为一个对象引用他们
优点：突破对单个MyISAM表的大小限制，通过将不同的表分布在多个磁盘上，提供啊访问效率。
tokuDB
特性：使用Fractal树索引保证了高效的插入性能
强大的压缩特性比INNODB高近10倍
支持在线DDL操作（增删查改）
使用Bulk Loader达到最快加载大量数据
提供了主从延迟的消除技术
适用场景：
日志数据    历史数据    在线DDL较频繁的场景。

2.单个索引、联合索引、主键索引
主键索引：一种特殊的唯一索引，在一张表中只能定义一个主键索引，用来标识唯一一条数据，用primary key创建
联合索引：索引可以覆盖多个数据列
唯一索引：保证数据记录的唯一性。
普通索引 ：加快数据的查询速度
索引可以极大的提高查询访问速度  但是会将低插入删除更新的速度
如果我们创建了(username,sex,age)的复合索引，那么其实相当于创建了：
(username,sex,age)，(username,sex)、(username,age)、(username)四个索引，这被称为最佳左前缀特性。
添加单个索引
ALTER TABLE `tf_user_index` ADD INDEX(`username`);
ALTER TABLE `tf_user_index` ADD INDEX(`sex`);
ALTER TABLE `tf_user_index` ADD INDEX(`age`);
添加联合索引
ALTER TABLE `tf_user_index` ADD INDEX `username_sex_age` (`username`, `sex`, `age`);
ALTER TABLE `tf_user_index` ADD INDEX `sex_age` ( `sex`, `age`);
3. mysql 怎么分表，以及分表后如果想按条件分页查询怎么办 (如果不是按分表字段来查询的话，几乎效率低下，无解)
如果只是为了分页，可以考虑这种分表，就是表的ID是范围性的，且ID是连续的，比如第一张表id是1到10万  第二张是10到20万  这样分页应该没有什么问题
如果是其他的分表方式，建议使用sphinx先建索引，然后查询分页
A：为什么要分页：当一张表的数据达到几千万时，你查询一次所花de时间会变多，如果有联合查询的话，会更复杂。分表就是为了减小数据库的负担，缩短查询de时间。

B：Mysql proxy：amoeba
做mysql的集群，利用amoeba
C：大数据量并且访问频繁的表，将其分为若干个表
D：利用merge存储引擎来实现分表
如果要把已有的大数据量表分开比较痛苦，所以用merge存储引擎来实现分表

4. 分表之后想让一个 id 多个表是自增的，效率实现

5. MySql 的主从实时备份同步的配置，以及原理 (从库读主库的 binlog)，读写分离

6. 写 SQL 语句。。。

7. 索引的数据结构，B+ 树

8.事务的四个特性，以及各自的特点（原子、隔离）等等，项目怎么解决这些问题
ACID属性（atomicity  consistent  isolation durable）
原子性：事务是一个原子操作单元，其对数据的修改要么全都执行要么全都不执行
一致性：在事务开始和完成时，数据都必须保持一致的状态，及要求事务做完后，要求满足数据库的一些完整性。这意味着相关的数据规则都必须应用于事务的修改，以保持数据的完整性；事务结束时所有的内部数据结构也都必修是正确的。
隔离性：数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。这意味着食物处理过程中的中间状态对外部是不可见的。
持久性：事务完成之后，它对数据的修改时永久性de，即使出现系统故障也能够保持。

9.数据库的锁：行锁，表锁；乐观锁，悲观锁
表锁：是MYSQL各存储引擎中最大颗粒度的锁定机制。
      特点：实现逻辑非常简单，带来的系统负面影响最小。所以获取锁和释放锁的速度很快。由于表及锁一次会将整个表锁定，所以可以很好的避免困扰我们的死锁问题。当然锁定颗粒度大所带来最大负面影响就是出现锁定资源争用的概率也会最高。表级锁分为读锁和写锁。
页锁 ：锁定粒度介于行级锁和表及所之间，所以获取锁定和所需要的资源开销，以及所能提供的并发处理能力也同样是介于上面二者之间。另外页级锁定和行级锁定一样会发生死锁。
行锁：行锁的最大特点就是锁定对象的颗粒度很小，也是目前各大数据库管理软件所实现的锁定颗粒度最小的。锁定颗粒度很小，所以发生锁定资源争用的概率也最小，能够给予应用程序尽可能大的并发处理能力而提高一些需要高并发应用系统的整体性能。。在并发处理能力上面有较大的优势，但是行级锁定也因此带来了不少弊端.由于锁定资源的颗粒度很小所以每次获取锁和释放锁需要做的事情也更多。行级锁容易发生死锁。
InnoDB的行级锁同样分为两种共享锁和排它锁，所以InnoDB实际上有四种锁，共享锁，排它锁，意向共享锁，意向排他锁{s,x,is,ix}
使用表级锁定的主要是MyISAM  Memorry CSV等一些非事务性存储引擎
行级锁主要是Innodb存储引擎和NDBCluster存储引擎，
页级锁，主要是BerkeleyDB存储引擎的锁定方式
MyISAM表锁优化建议：
缩短锁定时间    分离能并行的操作      合理利用读写优先级

悲观锁:它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制。悲观的缺陷是不论是页锁还是行锁，加锁的时间可能会很长，这样可能会长时间的限制其他用户的访问，也就是说悲观锁的并发访问性不好。
乐观锁（ Optimistic Locking ） :相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则则拒绝更新并返回用户错误的信息，让用户决定如何去做。乐观锁由程序实现，不会存在死锁问题。它适用的场景也相对乐观。但乐观锁不能解决脏读的问题
悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。[1]
乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。[1] 乐观锁不能解决脏读的问题。

10. 数据库事务的几种粒度；
表锁：表锁锁定颗粒度大
页锁：锁定粒度介于行级锁和表及所之间
行锁：行锁的最大特点就是锁定对象的颗粒度很小

11. 关系型和非关系型数据库区别
a数据存储方式不同
关系型和非关系型数据库的主要差异是数据存储的方式。关系型数据天然就是表格式的，因此存储在数据表
的行和列中。数据表可以彼此关联协作存储，也很容易提取数据。
与其相反，非关系型数据不适合存储在数据表的行和列中而是大块组合在一起。非关系型数据通常存储在数据集中，就像文档，键值对或者图结构。
b扩展方式不同
SQL和NOSQL数据库最大的差别可能是扩展方式上，要支持日益增长的需求当然要扩展

要支持更多并发量，SQL数据库是纵向扩展，也就是说提高处理能力，使用速度更快速的计算机，这样处理相同的数据集就更快了
因为数据存储在关系表中，操作的性能瓶颈可能涉及很多个表，这都需要通过提高计算机性能来客服。
虽然sql数据库有很大扩展空间，但最终肯定会达到纵向宽展的上限。而NoSQL数据库是横向扩展的，
而非关系型数据库存储天然就是分布式的，Nosql数据库的扩展可以通过给资源池添加更多普通的数据库服务器来分担负载
c对事务性的支持不同
如果数据操作需要高事务性或者复杂数据查询需要控制执行计划，那么传统的sql数据库从性能和稳定性当面考虑是您的最佳选择。
Sql数据库支持对事务原子性细粒度控制，并且抑郁回滚事务。
虽然NOsql数据库也可以使用事务操作，但稳定性方面没法和关系型数据库比较，所以它们真正的价值是在操作的扩展性和大数据量处理方面

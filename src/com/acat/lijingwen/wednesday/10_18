
***************************************************
多线程，建立多线程的方式，多线程不同阶段的状态
***************************************************
进程：指的是处于运行过程中的程序
线程：是进程的一个执行单元负责当前进程中程序的执行，一个进程至少有一个线程，一个进程中是可以有多个线程，这个应用程序也可以称之为多线程程序。（多线程就是可以同时做很多事情而互不影响）
（一）继承Thread类（由于java单继承的特性这方式很少用）
（二）实现Runnable接口
（三）实现Callable接口
实例代码详见buildThread.class
线程中具有五种基本状态：

新建状态：当线程对象对创建后即进入了新建状态
就绪状态：当线程调用了start()方法，线程就进入了就绪状态，线程已经做好了准备，随时等待cpu调度执行，并不会立即执行
运行状态：当cpu开始调度处于就绪状态的线程时，此时县城得以真正的执行
阻塞状态：处于运行状态中的线程由于某种原因暂时放弃对cpu的使用权，停止执行，此时进入阻塞状态直到其进入到就绪状态，才有机会再次被cpu调用进入到运行状态

1等待阻塞：运行状态中的线程执行wait（）方法使本线程进入等待阻塞状态
2同步阻塞：线程在获取synchronized同步锁失败（因为锁被其他线程所占用）它会进入同步阻塞状态
3其他阻塞：通过调用线程的sleep（）或join（）或发出了I/O请求时，鲜花曾会进入到阻塞状态。
死亡状态：线程执行完了或者因异常退出了run（）方法，该线程结束生命周期
***************************
JVM
***************************
Java 的内存模型以及 GC 算法
GC算法有：
标记清除算法：判断哪些数据需要清除，并且对他们进行标记 然后清楚被标记的数据。
该算法产生的碎片会比较多  当需要分配较大的对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。（适用于老年代。因为老年代回收的几率小且不频繁能减少内存碎片）
复制算法：操作存活对象   将可用内存按容量划分为大小相等的两块，每次只使用其中的一块 。当这一块内存用完需要进行垃圾收集时，就将存活者的对象复制到 另一块内存上，然后将第一块内存全部清除。但不会有内存碎片的问题，但空间会缩小一半。（适用于存活率低的情况）
标记整理算法：将废弃对象做上标记  然后将未标记的对象移到一边，最后清空另一边区域即可。这样就不会浪费空间也可以避免碎片化。（适用于存活率高的情况）
分代收集算法：根据对象存活周期的不同，将内存划分为新生代（使用复制算法）和老年代（标记整理算法）

10.18
上午完成了8-10点的安排   10-12未完成难受 。。。。
后面因为开题报告 下午主要看了会论文
此时正在刷搜狐笔试题 此题还不简单  好难哦****************



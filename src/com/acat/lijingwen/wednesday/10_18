
***************************************************
多线程，建立多线程的方式，多线程不同阶段的状态
***************************************************
进程：指的是处于运行过程中的程序
线程：是进程的一个执行单元负责当前进程中程序的执行，一个进程至少有一个线程，一个进程中是可以有多个线程，这个应用程序也可以称之为多线程程序。（多线程就是可以同时做很多事情而互不影响）
（一）继承Thread类（由于java单继承的特性这方式很少用）
（二）实现Runnable接口
（三）实现Callable接口
实例代码详见buildThread.class
线程中具有五种基本状态：

新建状态：当线程对象对创建后即进入了新建状态
就绪状态：当线程调用了start()方法，线程就进入了就绪状态，线程已经做好了准备，随时等待cpu调度执行，并不会立即执行
运行状态：当cpu开始调度处于就绪状态的线程时，此时县城得以真正的执行
阻塞状态：处于运行状态中的线程由于某种原因暂时放弃对cpu的使用权，停止执行，此时进入阻塞状态直到其进入到就绪状态，才有机会再次被cpu调用进入到运行状态

1等待阻塞：运行状态中的线程执行wait（）方法使本线程进入等待阻塞状态
2同步阻塞：线程在获取synchronized同步锁失败（因为锁被其他线程所占用）它会进入同步阻塞状态
3其他阻塞：通过调用线程的sleep（）或join（）或发出了I/O请求时，鲜花曾会进入到阻塞状态。
死亡状态：线程执行完了或者因异常退出了run（）方法，该线程结束生命周期
***************************
JVM
***************************
Java 的内存模型以及 GC 算法
GC算法有：
一．Java 的内存模型以及 GC 算法
GC算法有：
标记清除算法：判断哪些数据需要清除，并且对他们进行标记 然后清楚被标记的数据。
该算法产生的碎片会比较多  当需要分配较大的对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。（适用于老年代。因为老年代回收的几率小且不频繁能减少内存碎片）
复制算法：操作存活对象   将可用内存按容量划分为大小相等的两块，每次只使用其中的一块 。当这一块内存用完需要进行垃圾收集时，就将存活者的对象复制到 另一块内存上，然后将第一块内存全部清除。但不会有内存碎片的问题，但空间会缩小一半。（适用于存活率低的情况）
标记整理算法：将废弃对象做上标记  然后将未标记的对象移到一边，最后清空另一边区域即可。这样就不会浪费空间也可以避免碎片化。（适用于存活率高的情况）
分代收集算法：根据对象存活周期的不同，将内存划分为新生代（使用复制算法）和老年代（标记整理算法）
Java 的内存模型

2.jvm 性能调优都做了什么
无监控不调优;如果没有一个评价系统性能的手段，则调优没有意义  因为改了参数后测试不出来。
Java虚拟机调优主要涉及堆内存的调整和垃圾收集的调整。
堆内存：为了防止内存溢出  调优时将初始分配的内存和最大内存保持一致。
垃圾收集：
分代算法
      新生代：对象生存时间一般都比较短  存活对象少  可以使用复制算法。
      老年代：垃圾少一般使用标记整理算法
 主要调优的目的：
1.控制GC行为，2.控制堆栈大小3.控制内存分配
3. 介绍 JVM 中 7 个区域，然后把每个区域可能造成内存的溢出的情况说明
   Java内存区域：
线程私有内存区：
程序计数器    本地方法栈    线程栈   java堆
线程共享区：
方法区    常量池     直接内存区
JAVA虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的。
各区域内存溢出的情况：
1程序技术器
　个人理解—(记录当前线程运行到了那一行代码,多线程来回切换时知道从哪里开始继续执行)
唯一不会报错:OutOfMemoryError
java的多线程通过JVM切换时间片运行,某个线程在某个时间可以在运行也可能被挂起,当线程挂起之后,JVM再次调度怎么知道该线程要运行那条字节码指令呢
指令计数器在于该线程相关的内存区域记录该线程下一条指令,创建线程时分配,该该线程私有
　2线程栈
　　　创建一个栈帧用于存储局部变量表,操作数栈,动态链接,方法出口等信息
　　　每个栈空间默认大小0.5m,1.7调整为1m,每调用一次方法就会压入一个栈帧,如果压入栈帧深度过大,即方法调用层次过深,就会抛出StackOverFlow,SOF最常见的场景是递归中,当递归没法退出时,就会抛出此异常,Hotspot提供了参数改区域大小,使用-Xss:xxK,就可以修改默认大小
　　如果线程请求栈深度大于虚拟机所允许的深度,抛出StackOverflowError
　　　　程序存在死循环或者深度递归调用
　　无法申请到足够的内存抛出OutOfMemoryError
　　　　gc问题
　　　　内存泄漏
　3本地方法栈
　　主要是给调用本地方法的线程分配的,该区域和线程栈的最大区别就是,在该线程的申请的内存不受GC调度,需要调度者自己管理(使用流,线程的时候需要手动close),JDK中的Math类的大部分方法都是本地方法,一个值得注意的问题是,在执行本地方法的时候,不是运行字节码,所以说指令计数器没法记录下一条字节码指令,执行本地方法时,指令计数器置为undefined
　　本地方法栈和线程栈作用相似,区别在于线程栈为虚拟机执行的java方法服务,而本地方法栈为虚拟机使用到的Native(本地)方法服务
　　报错StackOverflowError和OutOfMemoryError,和线程栈相同
　4堆
　　堆是JVM中常见的,最为熟知的内存区,我们通常所说的GC就是在这块区域中进行的,所有的java对象都在这里分配,这也是JVM中最常见的,最为熟知的内存区,被所有线程共享对象在这里创建与销毁
　　如果堆上没有内存完成实例的分配就会报OutOfMemoryError
　5方法区
　　这块区域是用来存放JVM装载的class的类信息,包括:类的方法,静态变量,类型信息(接口/父类),我们使用放射技术时,所需要的信息就是从这里获取的
　　一般来说这个区域的回收是目标是针对常量池的回收和对类型的卸载
　　当方法区无法满足内存分配需求时,会抛出OutOfMemoryError
　6常量池
　　变量用final修饰,不能在修改它的值,所以就成了常量,而这常量将会存放在常量区,这些常量在编译时就知道占用空间的大小,但并不是说明该区域编译就固定了,运行期也可以修改常量池的大小,典型的场景是在使用String时,你可以调用String的intern(){返回字符串对象的规范化表示形式},JVM会判断当前所创建的String对象是否在常量池中,若有,则从常量区取,否则把该字符放在常量池中并返回,这时就会修改常量池的大小
　　无法申请内存抛出OutOfMemoryError
　7直接内存区
　　直接内存区并不是JVM可管理的内存区,在JDK1.4中体用的NIO中,实现类高效的R/W操作,这种高效的R/W操作就是通过管道机制实现的,而管道机制实际上使用了本地内存,这样就避免了从本地源文件复制JVM内存,再从JVM复制到目标文件的过程,直接从源文件复制到目标文件,JVM通过DierctByteBuffer操作直接内存
==？在JDK1.4中新加入了NIO类，引入了一种基于通道与缓冲区的I/O方式，它可以使用Native函数直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。
　内存不足报OutOfMemoryError
4.介绍 GC 和 GC Root 不正常引用。

GC roots  特指的是垃圾收集器的对象
GC会收集那些不是GC roots且没有被GC roots引用的对象。
一个对象可以属于多个root ，GC root
Class - 由系统类加载器(system class loader)加载的对象，这些类是不能够被回收的，他们可以以静态字段的方式保存持有其它对象。
Thread -活着的线程
Stack Local   java方法的local变量或参数
JNI Local-JNI方法的local变量或参数
JNI Global-全局JNI引用
Monitor Used  用于同步的监控对象
Held by JVM-用于JVM特殊目的的有GC保留的对象，但实际上这个与JVM的实现有关。可能已知的一些类型是：系统加载器
5.自己从 classload 加载方式，加载机制说开去，从程序运行时数据区，讲到内存分配，讲到 String 常量池，讲到 JVM 垃圾回收机制，算法，hotspot。反正就是各种扩展.

6. jvm 如何分配直接内存， new 对象如何不分配在堆而是栈上，常量池解析
  NIO可以分配直接内存
开启逃逸分析会分配到栈上
常量池  用于存放编译器生成的额各种字面量和符号引用
///////////////////////10-23更新//////////////////////////////

10.18
上午完成了8-10点的安排   10-12未完成难受 。。。。
后面因为开题报告 下午主要看了会论文
此时正在刷搜狐笔试题 此题还不简单  好难哦****************



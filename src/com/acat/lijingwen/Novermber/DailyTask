2019.11.2   早上早起大致复习了信息方面的基本规则     下午考了一个半小时的试，但是竟然做了5小时的车，自闭了
2019.11.3   看了老师推荐的GAN相关资料  下午打了会球
2019.11.4   早上开题报告完善，创新点基本成型       下午修改+排版“职点迷津”BP书   git打标签     完成了服务器搭建java环境
            git  打标签的原因/目的：标记提交的版本  容易查找  会和某次提交绑在一起
            廖雪峰：发布版本时 我们通常在版本库中打一个标签，这样就唯一确定了打标签时刻的版本。
            将来无论什么时候，就是把那个标签的时刻的历史版本取出来。所以标签也是版本库的一个快照。
            GIT的标签虽然是版本库的快照，但其实他就是只想某个commit的指针。虽然很像分支但是分支可以移动标
            签不可移动，所以创建和删除标签都市瞬间完成的。
            还有为什么commit存在还要引入tag？因为commit号是一串数字字符的混合体，tag直接找版本号就ok

            注意的是：标签总和某个commit挂钩  如果这个commit即出现在master分支 有出现在dev分支 那么这两个分支上都可以看到这个标签
            git tag -d (tag-name)删除tag
            git push origin <tagname> 推送某个标签到远程
            git push origin --tags  一次性推送全部尚未推送到远程的本地标签
            git push oorigin :refs/tags/tagname   当将标签推送到远程后想要删除需要使用下面的命令。
            git tag (tag-name)创建tag
            git branch  显示分支
            git  log  --pretty =oneline --abbrev-commit 显示提交日志
            git checkout branchname 在Git中打标签非常简单，首先，切换到需要打标签的分支上：
            git show tagname  显示tag的相关信息
            git tag -a <tagname> -m "blablabla"可以指定标签信息
            git  tag  october_V  166c64a  给某次提交打标签  比方说要对add merge这次提交打标签，它对应的commit id是f52c633，敲入命令

            linux(centos) 保存退出vi编辑
            保存命令
            按ESC键 跳到命令模式，然后：
            :w   保存文件但不退出vi
            :w file 将修改另外保存到file中，不退出vi
            :w!  强制保存，不推出vi
            :wq  保存文件并退出vi
            :wq! 强制保存文件，并退出vi
            q:  不保存文件，退出vi
            :q! 不保存文件，强制退出vi
            :e! 放弃所有修改，从上次保存文件开始再编辑
2019.11.05   早上继续开题报告的完善     下午打印了一下午材料   晚上学习动态sql
2019.11.06   推翻了之前的评价方式，找了一天的生成图像评价方法，最终得出还是用经典的  PSVR、SSIM 来做评价。晚上动态sql从set继续向下学。


            <where></where>用在  select语句里面比较多
            <set></set>set用在update里面

            //trim  用来定制想要功能，可以完成set 和 where 标记功能
            <trim prefix="WHERE" prefixoverride="AND|OR">
            prefixoverride:去掉第一个and 或者是 or
            <trim prefix="set" suffixoverride="," suffix="where id = #{id}">
            suffixoverride  去掉最后一个逗号（也可以是其他的标记，就像是上面前缀中的and 一样）suffix 后缀
            //比如where 标签就可以用
            <trim prefix="where" prefixOverrides="AND | OR">

            </trim>
           //比如 set标签
           <trim prefix="set" suffixOverides=",">
           </trim>

          ********************* if else *************************
           Mybatis里面没有else标签  但是可以使用when otherwise 标签来达到这样效果

          *****************<foreach>包含以下属性 *****************
          collection：必填，值为要迭代循环的集合类型  这个属性值的情况有很多
          item：变量名 值为从迭代对象中取出的每一个值
          index:索引的属性名在集合数组情况下为当前索引值；当迭代对象是map时，这个值为map的key
          open：整个循环内容的开头字符串
          close：整个循环内容的结尾字符串
          separator：每个循环的分隔符
           select  * from product_   where id in
          <foreach item="item" index="index" collection="list" open="("separator=","close=")">
             #{item}
          </foreach>

          这段代码的意思是  item 是占位符  完了对于需要查询的id的占位用
           open="("     separator=","    close=")"
           where id in('1','3','5')   各占位之间用‘,’分开 open于 (     close于 )

         *******************bind 标签类似与做字符串的拼接***************
                 <select id ="bindone"  resultType="Product" >
                     <bind name=" likename" value="'%' + name + '%'"  />
                     select * from   product_  where name like #{likename}
                 </select>


                  <select id="bindProduct" resultType="Product">
              		 <bind name="likename"  value="'%' + name + '%'" />
              		 select  *  from   product_  where name like #{likename}
              	 </select>

              	  这两段 上面的<select></select>哪里有问题勒？
2019.11.07  注解  日志

          log4j  用于记录调试信息
          *************日志*************
          日志级别可观察，一共有6个级别 TRACE DEBUG(可见) INFO WARN ERROR FATAL
                 logger.trace("跟踪信息");
                 logger.debug("调试信息");
                 logger.info("输出信息");
                 logger.warn("警告信息");
                 logger.error("错误信息");
                 logger.fatal("致命信息");

          输出格式：
                 %c  输出日志信息所属的类的全名
                 %d  输出日志时间点的日期或时间，默认格式是ISO8601 也可以在其后制定格式
                 %f  输出日志信息所属的类的类名
                 %l  输出日志事件的发生位置  技术处日志新ixde语句处于它所在的类的第几行
                 %m  输出代码中制定的信息 如 log(message)  中的message
                 %n  输出一个回车换行符  windows平台为rn  Unix 平台为n
                 %p  输出优先级
                 %r  输出自应用 启动到输出该日志信息所含非的毫秒数
                 %t  输出产生该日志时间的线程名
                 %5p [%t] (%F:%L) - %m%n 就表示
                 宽度是5的优先等级 线程名称 (文件名：行号)-信息  回车换行
          除了使用log4j.properties还可以使用xml格式进行配置

           # Global logging configuration
           log4j.rootLogger=debug, stdout
           # MyBatis logging configuration...
           #mybatis 的日志设置mybatis这个包的局部日志级别是trace
           # 因为sql语句属于trace  ，所以设置了一个局部的日志级别以便输出执行sql语句的信息
           log4j.logger.maybatis.how2java=TRACE
           # Console output...
           log4j.appender.stdout=org.apache.log4j.ConsoleAppender   #也就是到控制台
           log4j.appender.stdout.layout=org.apache.log4j.PatternLayout  #布局
           log4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n  #输出格式

            *************事务管理************
            同一个事务中  要是有一条语句出错其他的语句也完成不了 (此时有个条件  那就是表的类型 必须为Innodb  其他类型第一条数据仍然可以插入)
            Mysql中 只有当表的类型是INNODB  的时候  才支持事务  所以需要把表category_  的
            类型设置为INNODB，否则无法观察到事务
            修改表类型是
            alter  table  tablename ENGINE = innodb
            查看表的类型的sql
            show  table status  from  how2java;

            *************延迟加载*************
             作用是个啥？
             在进行数据查询时，为了提高数据库查询性能尽量使用单表查询，因为单表查询比多表查询速度要快
             如果查询单表就可以满足需求，一开始先查询单表，当需要关联信息时，在关联查询，当需要关联信息在查询
             这个就叫延迟加载。mybatis 提供延迟加载的功能用于service层
             resultType 将查询结果按照sql列名pojo属性名一致映射到pojo中。
             lazyLoadingEnabled 全局性设置懒加载   如果设为‘false’则所有相关联的都会被初始化加载
             aggressiveLazyLoading  当设置为 true  的时候，懒加载的对象可能被任何懒属性全部加载。否则，每个属性都按需加载。

             ***********Mybatis分页**********************
            XML方式
            <select id="PageTest"  reslutType="Category" >
                  select * from category_
                  <if test="start!=null and count!=null">
                      limit #{start},#{count}
                  </if>
            </select>

            注解方式
            @Select("select * from category_ limit #{start},#{count}")
            public List<Category> listByFenye(@Param("start") int start,Param("count") int count);

             插件  PageHelper  是分页插件 分页开发会更加便捷

            需要用到两个插件jsqlparser   pagehelper

            ***在测试插件的时候遇到了灵异事件  将方法全都注释掉竟然还是跑出来之前的东西  请赐予我一张符吧

2019.11.07  /****************Mybatis的一级缓存*********************
            一级缓存 基于Sqlsession默认开启  在操作数据库时需要构造Sqlsession在对象中有一个HashMap
            用于存储缓存数据。不同的sqlsession之间缓存数据区域是互相不影响的
            一级缓存的作用是sqlsession 范围的  当在同一个sqlsession中执行两次相同的sql、语句
            第一次执行完毕会将数据库中查询的数据写到缓存。
            第二次查询时会从缓存中获取数据，不再去底层数据库查询  从而能提高查询效率
            但是如果sqlsession  不同
                    sqlsession 相同 查询条件不同（当前一级缓存中还没有这个数据）
                    sqlsession相同 两次查询之间执行了增删改操作（可能会对当前数据有影响）
                    sqlsession相同 手动清楚了一级缓存
                等着情况的出现  一级缓存将会失去其作用。

            ******************二级缓存*****************
            启动二级缓存
            这个是在mybatis-config.xml中
            <setting name="cacheEnable" value="true"/>
            这个是在 mapper.xml中
            <cache/>以启动对Category对象的二级缓存
            让pojo实现序列化  让Category 实现序列化接口

            在同一个sessionFactory  下查询id=1的数据  只有第一次需要执行sql语句以后都是从缓存中取出。
            ******数据库连接池*****
            数据库连接池的必要性
            在使用开发基于数据库的web程序时
                 是建立数据库链接进行sql操作
                 断开数据库连接
            这种方式的弊端是：对于每一次数据库连接 使用完后都得断开 否则如果程序出现异常而未能关闭将会导致数据库系统中的内存泄漏，最终导致重启数据库
            这种开发不能控制被创建的连接对象数，系统资源会被毫无顾及的分配出去，如果连接过多 也可能导致内存泄漏  服务器崩溃


           数据库连接池：为数据库连接建立一个“缓冲池”。预先在缓冲池中放入一定数量的连接，当需要建立数据库链接时，只需从“缓冲池”
           中取出一个，使用完毕之后再放回去。
           数据库连接池负责分配管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是重新建立
           一个
           数据库连接池在初始化时创建一定数量的数据库连接放到连接池中，这些数据库连接的数量是由最小数据库连接数来设定
           无论这些数据库连接是否被使用连接池都将一直保证至少拥有折磨多的链接数量，连接池的最大数据库连接数量
           限定了这个连接池能占有的最大连接数，当应用程序向连接池请求的连接数超过对打连接数量时，这些请求将被加入到等待队列中
           数据库连接池优点：资源重用 （避免了重复创建链接）
                            更快的系统反应速度（在已经创建了若干数据库连接池，避免了数据库连接初始化和释放过程的时间开销）
                            新的资源分配手段对于多应用共享同一数据库的系统而言
                            统一的连接管理

           ******************Spring  和  Mybatis 的整合**********

              这里主要明白了
                    几个注解的用法
                    以及spring mybatis 整合及运行原理
                    注解
                     单个文件：
                     ContextConfiguration(Location="../applicationContext.xml")
                     ContextConfiguration(classes = SimpleConfiguration.class)
                     多个文件：
                     ContextConfiguration{"classpath*:/spring1.xml","classpath*:/spring2.xml"}
                     namespace 绑定接口  可以不用写接口实现类  mybatis会通过该绑定自动帮你找到对应要执行的sql
                     这也就是catgory.xml 添加 <mapper namespace="com.how2java.mapper.CategoryMapper">的原因


2019.11.11
              爬取所需数据集，看人家代码（但是数据集训练还是不知道怎么搞）

2019.11.12

            java内存模型     网上查合适训练网络    晚上看了部电影《我是谁：没有绝对的安全系统》
            线程之间如何通信及线程之间如何同步
            线程之间的通信机制有共享内存（隐式通信，通过共享公共状态）和消息传递（显示通信，没有公共状态，线程之间必须通过发送消息）
            java并发采用是共享内存模型
            实例域，静态域，和数组元素都存储在堆内存中，堆内存在线程之间共享.   局部变量和异常处理参数不会再线程之间共享
            线程之间的通信通过java内存模型（JMM）
            JMM抽象理解：线程的共享变量存储在主内存中，每个变量都有一个私有的本地内存，本地内存中存储了该线程的存储副本。本地内存是抽象概念，通过JMM控制来进行共享变量的读写
            线程之间的通信：线程A将共享变量刷到主内存线程B再从主内存取
            综上：JMM通过控制主内存与每个线程的本地内存之间的交互，来为JAVA程序员提供内存可见性保证

            重排序：主要为提高程序执行的性能
            编译器优化的重排序（编译器重排序）
            指令级并行的重排序（处理器重排序）
            内存系统的重排序（处理器重排序）
            JMM属于语言级的内存模型，通过两类重排序，为程序员提供一致的内存可见性


            写缓冲区可以保证指令流水线持续运行，可以避免由于处理器停顿下来等待向内存写入数据而产生的延迟；通过批处理的方式刷新写缓冲区减少对内存总线的占用
            但是写缓冲区仅对自己的处理器可见所以会导致处理器执行内存操作的顺序可能会与时间的操作执行顺序不一致
            happens-before
            as-if-serial: 不管怎么重排序
2019.11.13
          Spring的学习  开会再次明确了任务 以及开题里面的一些问题
          Spring IOC/DI第一节
          IOC（控制反转Inversion of Control）利用了工厂模式
          创建被调用者由spring容器来完成，然后注入调用者，因此被称为以来注入DI(Dependecy Injection)，依赖注入和控制反转是同一个概念。
          AOP（面向切面编程 Aspect -Oriented Programming）是代理模式
          SpingAOP只是实现了方法级别的连接点，在J2ee应用中Aop拦截到方法级别的操作就已经足够了。


          OOP面向对象编程  允许定义从上到下的关系，但并不适合定义从左到右的关系。例如日志汪汪水平的散不在所有对象层次中  OOP设计中会导致大量重复代码 不利于各个模块的重用。

          实现AOP技术住哟啊分为  采用动态代理技术  利用截取消息的方式对该消息进行装饰，以取代原有对象行为的执行。

          SprinIOC/DI：这里呢说明spring中配置文件和类之间关联

          对象的生命周期交给Spring来管理，直接从Spring哪里去获取一个对象。
          测试代码的过程是：
          先把spring容器摆好了  就是ApplicationContext  context =new ClassPathXMLApplicationContext(此处放入配置文件的路径例如：“ new String[] { "applicationContext.xml" }”)
          与传统方式不一样的是将对象的生命周期交由Spring来管理，直接从Spring 那里去获取一个对象。
          Category c = (Category)context.getBean(“此处为对应bean的name（name不可以重复）”)


          Spring注入对象第二节：
          <property ref    value 的区别>
          Ref引用一个已经存在的对象；可以引用其他的bean对象；使用ref的时候，spring容器会在引用后进行验证，验证当前的xml是否存在引用的bean。
          <property name=”p” ref=”c”>
          这里的ref是注入另一个对象  因为 在创建product的时候注入了一个category对象
          控制台会输出：信息: Pre-instantiating
          （这个表示通过spring拿到的Product对象已经被注入了category对象了）

          Spring系列教材 （三）- 注解方式 IOC/DI 
          首先是注入对象行为：
          首先在配置文件applicationContext.xml这个文件加入<context:annotation-config/>
          这个表示要以注解的形式进行注入了
          然后再pojo的实体类里面将需要注入的对象加注解
            @Autowried
          @Resource(name=”需要注入的bean的name”)
            还有就是给pojo中的set方法加@Autowried
          然后就是对Bean的注解：
          将配置文件的<bean></bean>全取消  只新增<context :component-scan bae-package=”pojo的包名”>然后为每个实体类加上@Component(“p”)

          Spring系列教材 （四）- aop 面向切面编程 
          AOP即Aspect Oeiented Program面向切面编程
          首先，在面向切面编程的思想里面把功能分为核心业务功能和周边功能
          周边功能比如性能统计 日志 事务管理等 在AOP思想里被定义为切面

          Eclipse报错
            Implicit super constructor Object() is undefined for default constructor. Must define an explicit constructor
          解决方案：把java的类库加载进去，在工程上右键选择属性->Java Build Path的Libraries->Add Library选择JRE System Library->点击Next->选择Execution environment并选择版本或workspace default jre->点击Finish。
          但是，似乎还是有问题还在找问题所在。


2019.11.14      创新基金申请书的撰写。
         顺序一致性：
         数据竞争的原因：当程序未正确同步时，就可能会存在数据竞争。(也就是说如果一个多线程程序能正确同步，这个程序将是一个没有数据竞争的程序)
         数据竞争的定义：在一个线程中写一个变量，在另一个线程中读同一个变量，而且写和读没有通过同步来排序。
         顺序一致性内存模型的两大特性：一个线程的所有操作都是按照程序的顺序来执行；（不管程序是否同步）所有线程都只能看到一个单一的操作执行顺序。每个操作必须院子执行。
         顺序一致性内存模型中的每个操作必须立即对任意线程可见。
         未同步程序在JMM中不但整体的执行顺序是无序的而且所有线程看到的操作执行顺序也可能不一致
         JMM的原则是在不改变（正确同步的）程序执行结果的前提下，尽可能地位编译器和处理器的优化打开方便之门。

          未同步程序在JMM中的执行顺序整体上是无序的，其执行结果无法预知。

          未同步程序在JMM和顺序一致性内存模型的差异如下：
          1.顺序，保证单线程内的操作会按程序的顺序执行   JMM并不保证单线程内的操作会按程序的顺序执行
          2.顺序，所有线程只能看到一只的操作执行顺序，jmm不保证看到的执行顺序合议制
          3.顺序，保证对所有内存读写操作都具有原子性。JMM不保证对64位long型和double型变量的写操作具有原子性

          数据通过总线在处理器和内存之间传递。 总线的工作机制保证任意时间点最多只能有一个处理器可以访问内存。这个特性保证了单个总线食物之中的内存读写操作具有原子性
          在一些32位的处理器上对64位数据的写操作具有原子性会有比较大的开销JVM鼓励但不强制对64为的double 和long型变量的写操作具有原子性。所有在JVM上可能会把一个
          64位的变量拆分为两个32位写操作来执行  这两个写操作就可能会被放入不同的总线事务中执行，此时这个64位的变量将不具有原子性。JSR-133内存模型JDK5之后要求  将64位的变量只能拆为两个32的写操作读操作必须得具有原子性，
          之前是可以拆分为两个32为的读写操作

2019.11.15-17  回家  周六去了山里面的庙里  很清静走的时候师傅还给我塞了好几个甜枣开心，好几年全凭印象竟然找到了，之前经过的水库现在进行干涸了全都长草了，时间真可怕，想当年还和我哥我姐来钓鱼。。。


2019.11.18  早上将创新基金的申请书基本完工 但是还有几点说的不是很明白，下午看了会双十一老
            师专门买的书，大致了解了一下，，发现了之前老师问的问题的较为合理的答案
            什么时候确定生成网络和判别网络处于较为平衡的状态?
            那就是判别器最理想的损失接近0.5，这个情况下对于判别其来说其无法从真实
            图像中区分出生成的图像。

             下午五点多开始学习了会java 主要内容是SSM框架的搭建  以及运行的流程步骤
             今天在eclipse中进行操作

             首先建立了Dynamic  Web Project
              包有  controller  用于前后的交流
                   mapper  数据的映射
                   pojo  对应数据库表的实体类  似乎一般会进行重写ToString方法
                   service 逻辑操作接口类里面将逻辑操作写好    实现类里面会注入mapper
              在src 下面建立applicationContext.xml   springMVC.xml
              web-inf  底下建立web.xml

              流程展示：
              例如将表里面的数据调用然后展示到前段界面：
              1.在浏览器进行访问这里面会将jsp 文件配置好前缀和后缀会配置好  完了就可以省略
              2.tomcat 根据web.xml 上的配置信息，拦截到/listCategory，并将其交由DispatcherServlet处理
              3.DispatcherServlet根据springMVC配置，将这次请求交由CategoryController 类进行处理
              4.Categorycontroller类注入CatrgoryServiceIMPL
              5.实例化CategoryServiceImpl时又注入了CategoryMapper
              6.根据ApplicationContext.xml中的配置信息将CategoryMapper和Category.xml关联起来
              7.这样拿到了实例化好了的CategoryController 并调用list方法
              8.在list方法中访问CategoryService并获取数据  并把数据放在CS上  接着服务器端跳转到listCategory.jsp
              中。

             //在IDEA里面进行ssm的创建

             学习CartoonGAN
             回宿舍看一会JAVA基础

2019.11.19   今天一天穿插着继续修改创新基金
             然后试着完成了分页的功能 中间有报Error creating bean with name “。。。controller”的错误将查阅发现是忘了给service实现类加@Service注解
             还有就是发现项目不管怎么该出来的内容都不变  原来是懒得毛病，运行的项目是另一个项目的url，就说还出现了灵异事件吗？真的想把自己打死。
             最后还有前端varStatus的用法
             看了双十一老师送我们的了礼物  GAN实战生成对抗网络  这几天看这本书的感受就是嗯 深奥 难懂


2019.11.20  看了GAN网络的原理   和DCGAN原理  试图寻找改进的地方  然而并没有明天继续
            然后就是down的代码对数据集进行了裁剪 标准化  但是效果不咋地  裁剪的时候会将一些主要的内容给裁掉  裁剪的范围是定死的
            明天继续改进  然后晚上安慰了一下朋友  然后思考了一下自己还有未来的某些事情 突然不想学习了哈哈哈  打到回府洗衣服


2019.11.21

            分页：首先要创建一个util 工具包 然后哦创建page 类 里面放入statr  last count（表示起始的数据是哪一个 最后一页的起始数据是什么  每页的数量 ）
            最后一页的计算方法  为  数据对每页的数量count 进行取余  若整除  那么最后一页的起始数据为total - count
            若不能则total - total%count

            Limit 后面可以跟两个参数  第一个参数offset 可选参数表示偏移量，如果不指定默认值为0 即偏移量为0 则从查询结果的第一条记录数开始   若偏移量为1则开始查询结果中第二条记录   下一个就是第3个数据了
            第二参数  记录数 表示返回结果的条数

            基于插件的分页：
            将分页的包PageHelper 和 jsqlparser.jar 包

            主要是配置applicationContext.xml
            <property name=”plugins”>
              <array>
            <bean class=”com,github.pagehelper.PageInterceptor”>
            <property name=”plugins”>
               <value>
            </value>
            </property>
            </bean>
            </array>
            </property>
            Controller :
            PageHelper.offersetPage(page.getStart(,5);
            Int total=(int )new PageInfo<>cs.getTotal();
            Page.caculateLast(total);

            防止减为负的：setStart  进行一个if 判断
            链接池的好处是不必每次连接都新建一个连接，可以直接从池中取，节约内存资源
            连接池：用池来管理Connection  这样可以重复使用 connection。有了池，所以我们就不用自己来创建connection
            而是通过池来获取Connection对象。当使用完connection调用close 不会真的吧池关闭  而是把Connection归还给池。池就可以子啊利用这个connection对象
            连接池C3p0链接池  ：
            数据库连接池的基本思想就是为数据库连接建立一个“缓冲池”。预先在缓冲池中放入一定数量的连接。通过设定连接池最大连接数来防止系统无尽的与数据库连接。
            ResultMap：比下面的更强大 如果查询出来的列名和pojo的属性名不一致，通过定义一个resultMap对列名和pojo属性名之间作一个映射关系。（高级映射，字段名称可以不一致，通过映射来实现
            ResultType:只有慢走ORM（object Relational Mapping,）对象映射关系时  数据库表中的字段名和实体类的属性完全一致时才能使用  否则才会出现数据不显示情况
            CRUD操作：明白了页面间的跳转和jsp页面到controller 之间的跳转。
            以及之间的重定向   redirect  转发 forward
            直接请求转发是   forward：
               客户端和浏览器只发出一次请求，servlet  html  jsp或其它信息资源，由第二个信息资源响应该请求  在请求对象request中  保存的对象对于每个信息资源是共享的

            间接请求转发是   redirect
               实际是两次HTTP请求，服务器端在相应第一次请求的时候，让浏览器再向另外一个url发出请求  从而能达到转发的目的

            直接转发就相当于：“A找B借钱，B说没有，B去找C借，借到借不到都会把消息传递给A”；
            　　间接转发就相当于："A找B借钱，B说没有，让A去找C借"。

            将数据集中的图像归一化：让模型更加稳定
            归一化是将样本的特征值转换到统一量纲下把数据映射到[-1,1]之间。

            什么时候用归一化？什么时候用标准化？
              （1）如果对输出结果范围有要求，用归一化。
              （2）如果数据较为稳定，不存在极端的最大最小值，用归一化。
              （3）如果数据存在异常值和较多噪音，用标准化，可以间接通过中心化避免异常值和极端值的影响。

          半下午+晚上 论文相关准被
          GRUB是一个来自GNU项目的多操作系统启动程序  (哈哈  偷听到GRUB不知道是啥顺手查了一下。get到了)





















第一章：并发编程的挑战
并发编程的目的：为了让程序运行的更快
上下文切换：任务从保存到再加载的过程就是一次上下文切换
上下文切换会影响多线程的执行速度
当并发执行累加操作不超过百万次 速度反而比串行执行累加操作要慢   因为线程有创建和上下文切换的开销
如何减少上下文切换？
方法：

1.无锁并发编程：多线程竞争锁时会引起上下文切换所以多线程处理数据时，可以用一些办法来避免使用锁，如将数据的ID按照Hash算法取模分段
不同的线程处理不同段的数据。
2.CAS算法：Java的Atomic包使用CAS算法来更新数据 而不需要加锁。（java.util.concurrent.atomic包方便程序员在多线程环境下无锁的进行原子操作：（一旦开始就会一直运行到结束，不会被线程调度机制打断的操作））
{
    《CAS是compareandswap的缩写  比较并替换。CAS有三个操作数：内存地址V  旧的预期值A   即将要更新的目标值B
    CAS是乐观锁技术 当多个线程尝试使用CAS同时更新一个同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试
    CAS有三个操作数，内存值V 旧的预期值A 要修改的新值B  当且仅当预期值A和内存值V相同时 修改内存值V修改为B否则什么都不做
    CAS无锁算法C实现：
    int compare_and_swap(int * reg,int oldval,int newval){
        ATOMIC();
        int old_reg_val=*reg;
        if(old_reg_val==oldval)
          *reg=newval;
          END_ATOMIC();
          return old_reg_val;
    }
    CSA仍然存在三大问题：
    1.循环时间长开销很大
    getAndAddInt方法执行时如果CAS失败会一直进行尝试。长时间不成功可能会给CPU带来很大的开销
    2.只能保证一个共享变量的原子操作
    当对一个共享变量执行操作时 我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，
    就无法保证操作的原子性，这个时候就可以用锁来保证原子性。
    3.ABA问题
    什么是ABA？
    如果内存地址V初次读取的值是A，并且在准备赋值的时候检查到它的值仍然为A，那我们就能说它的值没有被其他线程改变吗？
    如果在这段期间它的值曾经被改为B，后来又被改回为A那CAS操作就会误认为它从来没有被改变过。这个漏洞称为CAS操作的ABA问题。

    解决方法：java并发包为了解决这个问题    提供了一个带有标记的院子引用类 AtomicStampedReference
    通过控制变量值的版本来保证CAS的正确性。因此在使用在使用CAS前要考虑清楚“ABA”问题是否会影响程序并发的正确性，
    如果需要解决ABA问题，改用传统的互斥同步可能会比原子类更高效。
    》
    临界资源：对多个进程或者县城都可见的资源  容易产生争夺
    临界区：就是一段代码对临界资源操作的代码区称之为临界区
    同步也是一种高级的互斥，互斥也是某一种程度变相的同步其实这么说主要是因为同步和互斥的目的是相同的都是为了解决临界资源争夺

    同步：是一种合作的关系  未完成某种人去额外人建立的多个进程之间的协调调用，次序等待，传递消息告知资源占用情况
    互斥：是一种制约关系  当一个进程或者多个进程进入淋巴结去之后进行枷锁操作，西施其他进程不能进入临界区   只有当该进程解锁后其他人才可以是哟个这种技术汪汪通过阻塞完成

}
3.使用最少线程：避免创建不需要的线程
4.协程：在单线程里实现多任务的调度，丙子啊单线程里维持多个任务间的切换。

减少上下文切换实战
   JBOSS的工作线程在await  说明JBOSS线程池接收到的任务太少大量线程都闲着 减少JBOSS
   的工作线程数将maxThread降到100
避免死锁的几个方法：
1.避免一个线程同时获取多个锁
2.避免一个线程在所内同时占用多个资源，尽量保证每个锁只占用一个资源
3.尝试使用定时锁
4.对于数据库锁，加锁和解锁必须在一个数据可连接里否则会出现解锁失败的情况


资源限制的挑战：
指的是：程序执行的速度受限于计算机硬件资源或软件资源
硬件资源限制：有带宽 的上传和下载   硬盘读写速度  CPU处理速度
软件资源闲置有数据库的连接数和socket连接数

解决资源闲置的问题有考虑使用集群并行执行程序


第二章：
